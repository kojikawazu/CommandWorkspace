# イベント駆動アーキテクチャについて

システム内のサービスやコンポーネントが「イベント」を通じて非同期に連携するアーキテクチャスタイルです。各コンポーネントはイベントの発生に応じて処理を実行し、システム全体が反応的に動作するように設計されています。このアーキテクチャは特にマイクロサービスや分散システムで利用され、スケーラビリティや柔軟性の向上に寄与します。

## イベント駆動アーキテクチャの基本概念

- イベント
  - システム内で発生した「特定のアクションや変更」を表します。例として「注文の作成」「支払いの完了」「在庫の更新」などがあります。
  - 各イベントは「何が起きたか」を記録し、他のコンポーネントがそれを検知して処理を開始できるようにします。

- イベントプロデューサー（発行者）
  - イベントを生成して発行するコンポーネントで、何らかの状態変化やアクションが発生すると、イベントを発行して他のコンポーネントに知らせます。例えば、注文サービスが新規注文を受け付けた際に「注文作成」イベントを発行するケースです。

- イベントコンシューマー（受信者）
  - 発行されたイベントを受け取り、それに基づいて処理を行うコンポーネントです。例として、在庫サービスが「注文作成」イベントを受けて在庫を減らす処理を行います。

- メッセージブローカー
  - イベントプロデューサーとイベントコンシューマーの間でイベントを仲介するシステムです。Kafka、RabbitMQ、Amazon SNS/SQSなどがよく使われ、イベントの発行・受信を非同期に管理します。

## イベント駆動アーキテクチャの構成

イベント駆動アーキテクチャには、以下のような2つの主要なパターンがあります。

- シンプルなイベント通知
  - イベントプロデューサーが単に「何かが起きた」という通知のみをコンシューマーに送信します。コンシューマーはそれに基づいて自身で必要なデータを取得し、処理を行います。

- イベントキャリードステート転送
  - イベントプロデューサーが発行するイベントに状態情報（例えば「注文の詳細情報」など）を含めて送信します。これにより、コンシューマーは追加のデータ取得を行わずに処理が可能になります。

## イベント駆動アーキテクチャの流れ

具体的なシステムの流れとして、ECサイトの注文処理を例に挙げてみます。

- **1. 注文作成**: ユーザーが注文を作成すると、注文サービスが「注文作成」イベントを発行し、メッセージブローカーに送信します。
在庫更新: 在庫サービスが「注文作成」イベントを受け取り、注文内容に基づいて在庫を更新します。

- **2. 支払い処理**: 支払いサービスが「注文作成」イベントを受けて、支払いプロセスを開始します。

- **3. 通知送信**: 通知サービスが「支払い完了」や「注文発送準備完了」といったイベントを受け取り、ユーザーに通知メールを送信します。

このように、各サービスがイベントに反応して処理を行うことで、システム全体が非同期で柔軟に連携します。

## イベント駆動アーキテクチャのメリット

- 疎結合
  - 各コンポーネントがイベントを通じて連携するため、互いの状態や内部構造に依存しません。これにより、システムの変更や拡張が容易になります。

- スケーラビリティ
  - イベント処理を非同期で行うため、コンシューマーの負荷が高まった際にはその処理だけをスケールアウトできます。

- 拡張性
  - 新しいイベントを簡単に追加できるため、機能拡張が柔軟に行えます。たとえば、新たに「注文追跡サービス」を追加し、「注文発送準備完了」イベントを基に通知を送るといった機能追加が容易です。

- リアクティブな処理
  - イベントに基づいてリアルタイムに処理が進むため、迅速なレスポンスが求められるアプリケーションにも適しています。

## イベント駆動アーキテクチャのデメリット

- 可観測性の確保
  - 非同期かつ分散的に処理が進むため、トレーシングや監視が難しくなりがちです。各イベントの処理状況を追跡するためのモニタリングが必要です。

- デバッグの複雑さ
  - 複数のサービス間でイベントが連鎖的に処理されるため、エラーが発生した際に原因を特定するのが難しくなります。

- データの整合性の難しさ
  - 各コンポーネントが異なるデータソースを使用する場合、一貫性を保つために特別な工夫が必要です。分散トランザクションやサガパターンなどの対策が検討されます。

- 冪等性の必要性
  - イベントが重複して処理されても問題がないように、処理を冪等にする設計が必要です。例えば、同じ「注文作成」イベントが複数回処理されても在庫が過剰に減らないように注意が必要です。