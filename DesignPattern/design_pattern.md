# デザインパターン

## 1. 作成(Creational)パターン

これらのパターンはオブジェクトのインスタンス化に関連しており、オブジェクトの作成方法を柔軟にするためのものです。

- Singleton（シングルトン）: クラスに対してインスタンスが一つだけ存在することを保証するパターン。
- Factory Method（ファクトリーメソッド）: インスタンスの作成をサブクラスに任せるパターン。
- Abstract Factory（抽象ファクトリ）: 関連する一連のインスタンスを作成するためのインタフェースを提供するパターン。
- Builder（ビルダー）: 複雑なオブジェクトの構築とその表現を分離するパターン。
- Prototype（プロトタイプ）: 既存のオブジェクトをコピーして新しいオブジェクトを作成するパターン。

## 2. 構造(Structural)パターン

これらのパターンは、クラスやオブジェクトを組み合わせてより大きな構造を形成する方法に焦点を当てています。

- Adapter（アダプタ）: インターフェースの不一致を解消するためにクラスのインターフェースを変更するパターン。
- Composite（コンポジット）: オブジェクトを木構造で表し、個々のオブジェクトと組み合わせたオブジェクトを同一視できるようにするパターン。
- Proxy（プロキシ）: アクセス制御やコストの高いオペレーションの遅延実行など、他のオブジェクトへのアクセスを制御するオブジェクトを提供するパターン。
- Flyweight（フライウェイト）: 多数存在する細かいインスタンスを効率的に共有するためのパターン。
- Facade（ファサード）: 複雑なサブシステムに対する統一されたインターフェースを提供するパターン。
- Bridge（ブリッジ）: 抽象化と実装を分離し、それぞれを独立して変更できるようにするパターン。
- Decorator（デコレータ）: オブジェクトに動的に新しい責任を追加するパターン。

## 3. 振る舞い(Behavioral)パターン

これらのパターンはオブジェクト間の通信の効率を高め、責任の分散を助けます。

- Observer（オブザーバー）: オブジェクト間の依存関係を最小限にしながら、一つのオブジェクトの状態変化を他の依存オブジェクトに通知するパターン。
- Strategy（ストラテジー）: 実行時にアルゴリズムを選択するパターン。
- Command（コマンド）: 要求をオブジェクトの形でカプセル化し、パラメータを用いてメソッドを実行するパターン。
- State（ステート）: オブジェクトの状態変化に応じてオブジェクトの振る舞いを変更するパターン。
- Visitor（ビジター）: 操作をオブジェクト構造の要素に加えるパターン。要素のクラスを変更せずに新しい操作を簡単に追加できる。
- Mediator（メディエータ）: オブジェクト間の直接的な通信を避け、代わりに通信を仲介するオブジェクトを介して行うパターン。
- Iterator（イテレータ）: コレクションの要素に順にアクセスする方法を提供するパターン。
- Memento（メメント）: オブジェクトの状態を保存して後で取り出せるようにするパターン。
- Template Method（テンプレートメソッド）: アルゴリズムの構造をメソッドに定義し、一部をサブクラスでオーバーライドするパターン。
- Chain of Responsibility（チェーンオブレスポンシビリティ）: 複数のオブジェクトに処理の機会を提供するパターン。


## 5つの採用パターン

1. Singleton（シングルトン）

- 適用シナリオ: 
  - システム全体で共有されるべき唯一のリソースやサービス（例：データベースの接続プール、ログファイルのハンドラー、環境設定など）に対してインスタンスが一つだけ必要な場合。
- 目的: 
  - インスタンスが一つだけ存在することを保証し、グローバルなアクセスポイントを提供することで、リソースの一貫性と制御を維持する。

2. Factory Method（ファクトリーメソッド）

- 適用シナリオ:
  - クラスがそのインスタンスの型を事前に知ることなく、派生型のオブジェクトを生成したい場合。具体的なオブジェクトの作成をサブクラスが担当し、基底クラスのコードはそれらの具体的なクラスから独立している場合に適しています。
- 目的:
  - クラスの柔軟性を高めるために、オブジェクトの生成をサブクラスに委ねる。これにより、クラス間の結合度を下げ、拡張性を向上させる。

3. Abstract Factory（抽象ファクトリ）

- 適用シナリオ:
  - システムが複数の製品群を扱う必要があり、関連するオブジェクト群を一貫して生成する必要がある場合（例：異なるUIエレメントのファミリーで、それぞれが特定のOSに適合するようにデザインされている場合）。
- 目的:
  - 関連する一連のオブジェクト群を作成するためのインタフェースを提供し、具体的なクラスに依存することなく、製品のファミリーを容易に切り替えられるようにする。

4. Builder（ビルダー）

- 適用シナリオ:
  - 複雑なオブジェクト（多くのパラメータや構成要素を持つオブジェクト）を段階的に構築する必要がある場合、または同じ構築プロセスで異なる表現を生成したい場合。
- 目的:
  - 構築のプロセスを特定のオブジェクトの表現から分離し、同じ構築プロセスを使用して異なるタイプのオブジェクトを生成する。これにより、コンストラクターのオーバーロードが多数発生するのを避け、最終オブジェクトの構築をより制御しやすくする。

5. Prototype（プロトタイプ）

- 適用シナリオ:
  - オブジェクトの種類が実行時に動的に決定される場合や、オブジェクトの作成が高コスト（リソース消費が大きい、時間がかかる等）な場合に、既存のオブジェクトを複製することで新しいインスタンスを生成したい場合。
- 目的:
  - 既存のオブジェクトをプロトタイプとして使用し、それを複製することで新しいインスタンスを生成する。これにより、オブジェクトの作成コストを節約し、柔軟にオブジェクトを生成できるようにする。


